global !p
import php_namespace_detect as nsd
def get_clsfile_return(path):
	definition = '{} {} '.format(
		nsd.get_class_type(path), nsd.get_class_name(path)
	)
	namespace = nsd.get_namespace(path)

	if not namespace:
		return definition
	else:
		return "namespace {};\n\n{}".format(namespace, definition)

def full_path():
	return vim.current.buffer.name
endglobal

snippet ns "PHP Namespace" !bs
namespace `!p snip.rv = nsd.get_namespace(full_path())`;
endsnippet

snippet _ns "Inline PHP Namespace" !s
`!p snip.rv = nsd.get_namespace(full_path())`
endsnippet

snippet clsfile "PHP Class/Interface File" !bs
<?php
`!p snip.rv = get_clsfile_return(full_path())`$1
{
	$0
}
endsnippet

snippet tsts "PHPUnit Tests File" !bs
<?php
namespace `!p snip.rv = nsd.get_namespace(full_path())`;

use PHPUnit_Framework_TestCase;
use Mockery as m;

`!p snip.rv = nsd.get_class_type(full_path()) + ' ' + nsd.get_class_name(full_path())` extends ${1:PHPUnit_Framework_TestCase}
{
	public function setUp()
	{
		$0
	}

	public function tearDown()
	{
		m::close();
	}
}
endsnippet

snippet irepofn "Repository Interface Functions" !bs
public function findAll();
public function find($id);
public function create($1);
public function update($1);
public function save($1);
endsnippet

snippet clsrepofn "Repository Class Functions" !bs
public function findAll()
{
	throw new \Exception("Not implemented");
}

public function find($id)
{
	throw new \Exception("Not implemented");
}

public function create($1)
{
	throw new \Exception("Not implemented");
}

public function update($1)
{
	throw new \Exception("Not implemented");
}

public function save($1)
{
	throw new \Exception("Not implemented");
}
endsnippet

snippet _c "Constructor" !bs
public function __construct($1)
{
	$0
}
endsnippet
